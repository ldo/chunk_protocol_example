#!/usr/bin/python3
#+
# Example client for chunk protocol, using asyncio.
#-

import sys
from weakref import \
    ref as weak_ref
import socket
import asyncio
import getopt
import common
from common import \
    chunk, \
    ID

loop = asyncio.get_event_loop()

#+
# Useful stuff
#-

async def send_all(to_socket, contents) :

    done = loop.create_future()
    w_loop = weak_ref(loop)

    def write_more() :
        nonlocal contents
        loop = w_loop()
        assert loop != None, "event loop has gone away"
        try :
            written = to_socket.send(contents)
        except OSError as err :
            done.set_exception(err)
            written = None
        #end try
        if written != None :
            contents = contents[written:]
            if len(contents) == 0 :
                done.set_result(None)
            #end if
        #end if
        if done.done() :
            loop.remove_writer(to_socket)
        #end if
    #end write_more

#begin send_all
    if len(contents) != 0 :
        loop.add_writer(to_socket, write_more)
    else :
        done.set_result(None)
    #end if
    await done
#end send_all

async def receive_all(from_socket, n) :
    "reads n bytes from from_socket, raising an exception if" \
    " EOF reached."

    done = loop.create_future()
    w_loop = weak_ref(loop)
    result = b""

    def read_more() :
        nonlocal n, result
        loop = w_loop()
        assert loop != None, "event loop has gone away"
        try :
            data = from_socket.recv(n)
        except OSError as err :
            done.set_exception(err)
            data = None
        #end try
        if data != None :
            if len(data) == 0 :
                done.set_exception(IOError("EOF on socket"))
            else :
                result += data
                n -= len(data)
                if n == 0 :
                    done.set_result(result)
                #end if
            #end if
        #end if
        if done.done() :
            loop.remove_reader(from_socket)
        #end if
    #end read_more

#begin receive_all
    if n != 0 :
        loop.add_reader(from_socket, read_more)
    else :
        done.set_result(b"")
    #end if
    return await done
#end receive_all

async def server_request(conn, id, contents) :
    await send_all(conn, chunk.make(id, contents))
    header = await receive_all(conn, 8)
    response = header + await receive_all \
      (
        conn,
        chunk.extract_header(header)[1]
      )
    response = chunk.extract(response)[:2]
    return response
#end server_request

#+
# Actions to perform
#-

def action_delay(interval) :

    def doit(server) :
        return asyncio.sleep(interval)
    #end doit

#begin action_delay
    return doit
#end action_delay

def action_request(arg) :

    def unescape(s) :
        rest = s
        t = b""
        while True :
            pos = rest.find("%")
            if pos < 0 :
                t += rest.encode("ascii")
                break
            #end if
            if pos + 3 > len(rest) :
                raise SyntaxError("truncated %%-sequence in %s" % repr(arg))
            #end if
            t += rest[:pos].encode("ascii")
            n = 0
            for d in rest[pos + 1:pos + 3] :
                if '0' <= d <= '9' :
                    d = ord(d) - ord('0')
                elif 'a' <= d <= 'f' :
                    d = ord(d) - ord('a') + 10
                elif 'A' <= d <= 'F' :
                    d = ord(d) - ord('A') + 10
                else :
                    raise SyntaxError("bad %%-sequence in %s" % repr(arg))
                #end if
                n = n * 16 + d
            #end for
            t += bytes((n,))
            rest = rest[pos + 3:]
        #end while
        return t
    #end unescape

    op_id = None
    op_args = []

    def doit(server) :
        return server_request(server, op_id, op_args)
    #end doit

#begin action_request
    items = arg.split(":")
    op_id = unescape(items[0])
    if len(op_id) != 4 :
        raise SyntaxError("opcode not 4 bytes: %s" % repr(op_id))
    #end if
    items = items[1:]
    if len(items) == 1 and "=" not in items[0] :
        op_args = unescape(items[0])
    else :
        for item in items :
            item_id, item_contents = item.split("=")
            item_id = unescape(item_id)
            if len(item_id) != 4 :
                raise SyntaxError("content subchunk id not 4 bytes: %s" % repr(item_id))
            #end if
            op_args.append((item_id, unescape(item_contents)))
        #end for
    #end if
    return doit
#end action_request

available_actions = \
    {
        "delay" :
            {
                "action" : action_delay,
                "arg_conv" : float,
            },
        "request" :
            {
                "action" : action_request,
                "arg_conv" : lambda s : s,
            },
    }

#+
# Mainline
#-

opts, args = getopt.getopt \
  (
    sys.argv[1:],
    "",
    []
  )
if len(args) == 0 :
    raise getopt.GetoptError("nothing to do")
#end if
actions = []
for item in args :
    op, arg = item.split(":", 1)
    if op not in available_actions :
        raise getopt.GetoptError("unrecognized action %s" % repr(op))
    #end if
    action = available_actions[op]
    try :
        argval = action["arg_conv"](arg)
    except ValueError :
        raise getopt.GetoptError \
          (
            "arg %s is not valid for op %s" % (repr(arg), op)
          )
    #end try
    actions.append({"name" : item, "action" : action["action"](argval)})
#end for

async def mainline() :
    server = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    server.connect(common.socket_name)
    for action in actions :
        sys.stdout.write("action: %s\n" % action["name"])
        sys.stdout.flush()
        result = await action["action"](server)
        if result != None :
            sys.stdout.write(" result: %s\n" % repr(result))
        #end if
    #end for
    server.close()
#end mainline

loop.run_until_complete(mainline())
